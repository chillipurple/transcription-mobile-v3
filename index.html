<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>HEP Mobile Transcriber</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #1e293b;
      --panel-light: #334155;
      --panel-dark: #0f172a;
      --text: #f1f5f9;
      --text-muted: #94a3b8;
      --text-dim: #64748b;
      --accent: #10b981;
      --accent-dark: #059669;
      --danger: #ef4444;
      --warning: #f59e0b;
      --success: #22c55e;
      --border: #475569;
      --border-light: #64748b;
      --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
      --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1);
    }

    * { box-sizing: border-box; }
    
    /* Prevent viewport shifting and zooming */
    html {
      position: fixed;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    body {
      width: 100%;
      height: 100%;
      overflow-x: hidden;
      overflow-y: auto;
      position: relative;
      /* Prevent double-tap zoom globally */
      touch-action: manipulation;
      -webkit-text-size-adjust: 100%;
      -ms-text-size-adjust: 100%;
    }

    /* Container centering and width control */
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      display: grid;
      gap: 24px;
      padding-bottom: 120px;
      width: 100%;
      box-sizing: border-box;
    }

    /* Header */
    .header {
      background: linear-gradient(135deg, var(--panel-dark) 0%, var(--panel) 100%);
      padding: max(env(safe-area-inset-top), 16px) 20px 16px;
      border-bottom: 1px solid var(--border);
      box-shadow: var(--shadow);
      position: sticky;
      top: 0;
      z-index: 40;
    }
    
    .header h1 {
      margin: 0;
      font-size: 20px;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent) 0%, var(--success) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .header .subtitle {
      color: var(--text-muted);
      font-size: 14px;
      margin-top: 4px;
      font-weight: 400;
    }

    /* Main layout */
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      display: grid;
      gap: 24px;
      padding-bottom: 120px; /* Space for mobile dock */
    }

    /* Cards */
    .card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      box-shadow: var(--shadow);
      transition: all 0.2s ease;
    }
    
    .card:hover {
      border-color: var(--border-light);
    }

    .card-title {
      font-size: 16px;
      font-weight: 600;
      margin: 0 0 16px 0;
      color: var(--text);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .card-title .icon {
      width: 20px;
      height: 20px;
      opacity: 0.8;
    }

    /* Audio Controls Section */
    .audio-section {
      background: linear-gradient(135deg, var(--panel) 0%, var(--panel-light) 100%);
    }

    .file-upload {
      margin-bottom: 20px;
    }

    .file-input-wrapper {
      position: relative;
      display: block;
      width: 100%;
    }

    .file-input {
      width: 100%;
      padding: 16px;
      background: var(--panel-dark);
      border: 2px dashed var(--border);
      border-radius: 12px;
      color: var(--text-muted);
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: center;
    }

    .file-input:hover, .file-input:focus {
      border-color: var(--accent);
      background: var(--panel);
    }

    .file-name {
      margin-top: 8px;
      font-size: 14px;
      color: var(--text-muted);
      text-align: center;
    }

    /* Audio controls grid */
    .audio-controls {
      display: grid;
      grid-template-columns: auto auto auto auto 1fr;
      gap: 12px;
      align-items: center;
      margin-bottom: 20px;
    }

    .time-display {
      font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
      font-size: 14px;
      color: var(--text-muted);
      background: var(--panel-dark);
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid var(--border);
    }

    /* Progress bar */
    .progress-container {
      margin-bottom: 20px;
    }

    .progress-bar {
      width: 100%;
      height: 8px;
      background: var(--panel-dark);
      border-radius: 4px;
      position: relative;
      cursor: pointer;
      border: 1px solid var(--border);
    }

    .progress-fill {
      height: 100%;
      background: var(--accent);
      border-radius: 4px;
      width: 0%;
      transition: width 0.1s ease;
    }

    .progress-slider {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 20px;
      height: 20px;
      background: var(--accent);
      border-radius: 50%;
      cursor: grab;
      border: 2px solid white;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      left: 0%;
    }

    .progress-slider:active {
      cursor: grabbing;
    }

    /* Play controls */
    .play-controls {
      display: grid;
      grid-template-columns: 1fr 1.5fr 1fr;
      gap: 12px;
      margin-bottom: 20px;
    }

    .play-controls button {
      padding: 16px;
      font-size: 16px;
      font-weight: 600;
      border-radius: 12px;
      transition: all 0.2s ease;
    }

    /* Loop controls */
    .loop-controls {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 12px;
      margin-bottom: 12px;
    }

    .loop-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 13px;
      color: var(--text-muted);
      padding: 8px 0;
    }

    /* Form elements */
    input, select, button, textarea {
      font-family: inherit;
      font-size: 16px;
      border: 1px solid var(--border);
      border-radius: 10px;
      transition: all 0.2s ease;
    }

    input, select, textarea {
      background: var(--panel-dark);
      color: var(--text);
      padding: 12px 16px;
    }

    input:focus, select:focus, textarea:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgb(16 185 129 / 0.1);
    }

    input[type="number"] {
      width: 80px;
    }

    /* Buttons */
    button {
      background: var(--panel-light);
      color: var(--text);
      border: 1px solid var(--border);
      padding: 12px 16px;
      cursor: pointer;
      font-weight: 500;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    button:hover {
      background: var(--border);
      transform: translateY(-1px);
    }

    button:active {
      transform: translateY(0);
    }

    button.primary {
      background: var(--accent);
      color: white;
      border-color: var(--accent-dark);
      font-weight: 600;
    }

    button.primary:hover {
      background: var(--accent-dark);
    }

    button.danger {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
    }

    button.ghost {
      background: transparent;
      border-color: var(--border);
    }

    /* Editor section */
    .editor-section {
      grid-column: 1 / -1;
    }

    .editor-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .word-count {
      font-size: 14px;
      color: var(--text-muted);
      font-family: 'SF Mono', Monaco, monospace;
    }

    .editor {
      width: 100%;
      min-height: 50vh;
      resize: vertical;
      background: var(--panel-dark);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 20px;
      border-radius: 12px;
      line-height: 1.6;
      font-size: 16px;
      font-family: system-ui, sans-serif;
    }

    .editor:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgb(16 185 129 / 0.1);
    }

    /* Toolbar */
    .toolbar {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 12px;
      margin-top: 16px;
    }

    .toolbar button, .toolbar select {
      padding: 10px 12px;
      font-size: 14px;
    }

    /* Status indicators */
    .status-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 16px;
      padding: 12px 16px;
      background: var(--panel-dark);
      border-radius: 8px;
      font-size: 13px;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      border-radius: 6px;
      font-weight: 600;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .badge.success {
      background: var(--success);
      color: white;
    }

    .badge.warning {
      background: var(--warning);
      color: var(--panel-dark);
    }

    .badge.danger {
      background: var(--danger);
      color: white;
    }

    /* Responsive design */
    @media (min-width: 768px) {
      .container {
        grid-template-columns: 1fr 1fr;
        gap: 32px;
        padding: 32px;
      }
      
      .audio-section {
        grid-column: 1 / -1;
      }
      
      .audio-controls {
        grid-template-columns: auto auto auto 1fr;
      }
      
      .play-controls {
        grid-template-columns: 1fr 2fr 1fr;
      }
    }

    @media (max-width: 480px) {
      .container {
        padding: 16px;
        gap: 16px;
      }
      
      .card {
        padding: 16px;
      }
      
      .play-controls {
        grid-template-columns: 1fr;
        gap: 8px;
      }
      
      .loop-controls {
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }
      
      .audio-controls {
        grid-template-columns: 1fr;
        gap: 8px;
      }
      
      .toolbar {
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }
    }

    /* Mobile dock */
    .mobile-dock {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 50;
      background: var(--panel);
      border-top: 1px solid var(--border);
      padding: 16px 20px;
      padding-bottom: max(16px, env(safe-area-inset-bottom));
      box-shadow: var(--shadow-lg);
      /* Prevent double-tap zoom */
      touch-action: manipulation;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }

    .dock-controls {
      display: grid;
      grid-template-columns: 1fr 2fr 1fr;
      gap: 12px;
      max-width: 400px;
      margin: 0 auto;
    }

    .dock-controls button {
      padding: 14px;
      font-weight: 600;
      border-radius: 12px;
      /* Prevent double-tap zoom */
      touch-action: manipulation;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }

    @media (min-width: 768px) {
      .mobile-dock {
        display: none;
      }
      
      .container {
        padding-bottom: 32px;
      }
    }

    /* Alerts and warnings */
    .alert {
      padding: 16px;
      border-radius: 12px;
      margin-bottom: 20px;
      border: 1px solid;
      font-size: 14px;
      line-height: 1.5;
    }

    .alert.warning {
      background: rgb(245 158 11 / 0.1);
      border-color: var(--warning);
      color: var(--warning);
    }

    .alert.danger {
      background: rgb(239 68 68 / 0.1);
      border-color: var(--danger);
      color: var(--danger);
    }

    /* Help section improvements */
    .help-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .help-list li {
      padding: 8px 0;
      border-bottom: 1px solid var(--border);
      color: var(--text-muted);
      font-size: 14px;
    }

    .help-list li:last-child {
      border-bottom: none;
    }

    .help-list strong {
      color: var(--text);
    }

    .kbd {
      background: var(--panel-dark);
      border: 1px solid var(--border);
      border-bottom-width: 2px;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 11px;
      font-family: 'SF Mono', Monaco, monospace;
      color: var(--text-muted);
    }

    /* Hide audio element */
    .audio-element {
      position: absolute;
      width: 0;
      height: 0;
      opacity: 0;
      pointer-events: none;
    }

    /* Footer */
    .footer {
      text-align: center;
      color: var(--text-dim);
      font-size: 12px;
      padding: 32px 0;
      border-top: 1px solid var(--border);
      margin-top: 32px;
    }
  </style>
</head>
<body>
  <header class="header">
    <h1>🎙️ HEP Mobile Transcriber</h1>
    <div class="subtitle">Professional audio transcription on your phone</div>
  </header>

  <div id="envWarning" class="alert warning" style="display:none; margin: 16px 20px 0;">
    <strong>Browser Compatibility Issue:</strong> If the file picker doesn't open, tap the three dots (⋯) and choose <strong>Open in Chrome</strong>. Some in-app browsers block file uploads. Make sure your audio file is saved locally (Downloads/Files), not just in cloud storage.
  </div>

  <main class="container">
    <!-- Audio Controls Section -->
    <section class="card audio-section">
      <h2 class="card-title">
        <span class="icon">🎵</span>
        Audio Controls
      </h2>
      
      <div class="file-upload">
        <label for="audioFile" class="file-input-wrapper">
          <input id="audioFile" type="file" accept=".mp3,.m4a,.aac,.wav,.ogg,.oga,.3gp,.m4b,audio/*" class="file-input" />
        </label>
        <div id="fileName" class="file-name">No file selected</div>
      </div>

      <audio id="player" preload="metadata" class="audio-element" playsinline disablepictureinpicture controlslist="nodownload noplaybackrate noremoteplayback" x-webkit-airplay="deny"></audio>

      <div class="audio-controls">
        <label for="skipSeconds" style="font-size: 14px; color: var(--text-muted);">Skip</label>
        <input id="skipSeconds" type="number" value="5" min="1" max="30" />
        <label for="speed" style="font-size: 14px; color: var(--text-muted);">Speed</label>
        <select id="speed">
          <option value="0.4">0.4×</option>
          <option value="0.5">0.5×</option>
          <option value="0.6">0.6×</option>
          <option value="0.7">0.7×</option>
          <option value="0.8">0.8×</option>
          <option value="0.9">0.9×</option>
          <option value="1" selected>1.0×</option>
          <option value="1.1">1.1×</option>
          <option value="1.25">1.25×</option>
          <option value="1.5">1.5×</option>
        </select>
        <div class="time-display" id="timeReadout">00:00 / 00:00</div>
      </div>

      <div class="progress-container">
        <div class="progress-bar" id="progressBar">
          <div class="progress-fill" id="progressFill"></div>
          <div class="progress-slider" id="progressSlider"></div>
        </div>
      </div>

      <div class="play-controls">
        <button id="backBtn">⏪ Back</button>
        <button id="playBtn" class="primary">▶️ Play</button>
        <button id="fwdBtn">⏩ Forward</button>
      </div>

      <div class="loop-controls">
        <button id="setLoopIn">🔵 Loop In</button>
        <button id="setLoopOut">🔴 Loop Out</button>
        <button id="toggleLoop" class="ghost">Loop: Off</button>
      </div>

      <div class="loop-info">
        <span>In: <span id="loopIn">–</span> | Out: <span id="loopOut">–</span></span>
        <span>Save: <span class="badge success" id="autosaveBadge">CHECKING</span></span>
      </div>
    </section>

    <!-- Transcript Editor -->
    <section class="card editor-section">
      <div class="editor-header">
        <h2 class="card-title">
          <span class="icon">📝</span>
          Transcript Editor
        </h2>
        <div class="word-count" id="countInfo">0 chars • 0 words</div>
      </div>

      <textarea id="editor" class="editor" placeholder="Start typing your transcript here... 

• Use the audio controls above to play, pause, and navigate
• Insert timestamps and speaker labels using the buttons below
• Your work auto-saves as you type"></textarea>

      <div class="toolbar">
        <button id="insertTs">⏰ Timestamp</button>
        <select id="speakerPreset">
          <option value="">👤 Speaker...</option>
          <option>Interviewer:</option>
          <option>Translator:</option>
          <option>Speaker 1:</option>
          <option>Speaker 2:</option>
        </select>
        <button id="markBtn">❓ Mark Unclear</button>
        <button id="manualSave" class="ghost">💾 Save Now</button>
        <button id="copyBtn">📋 Copy</button>
        <button id="emailBtn">📧 Email to...</button>
        <button id="downloadBtn" class="primary">💾 Download</button>
        <button id="clearBtn" class="danger">🗑️ Clear</button>
        <button id="recoverBtn" class="ghost" style="display:none;">🔄 Recover</button>
      </div>

      <div class="status-bar">
        <span id="lastSaved" style="color: var(--text-muted);">Ready to save</span>
        <div style="display: flex; gap: 8px; align-items: center;">
          <span style="color: var(--text-muted); font-size: 12px;">Auto-save:</span>
          <span class="badge success" id="autosaveStatus">ON</span>
        </div>
      </div>

      <div id="saveWarning" class="alert danger" style="display:none; margin-top: 16px;">
        <strong>⚠️ Save Failed!</strong> Your text is only stored in memory. Use "Download" or "Copy" to backup your work immediately.
      </div>
    </section>

    <!-- Quick Help -->
    <section class="card">
      <h2 class="card-title">
        <span class="icon">💡</span>
        Quick Help
      </h2>
      
      <ul class="help-list">
        <li><strong>Load audio:</strong> Tap the file area above to select MP3, M4A, WAV, or other audio files</li>
        <li><strong>Playback:</strong> Use Play/Pause, Back/Forward buttons. Adjust speed as needed</li>
        <li><strong>Looping:</strong> Set "Loop In" and "Loop Out" points, then toggle Loop on for difficult sections</li>
        <li><strong>Timestamps:</strong> Click "Timestamp" to insert current audio time</li>
        <li><strong>Email:</strong> "Email to..." opens your email app with the transcript attached or in the body</li>
        <li><strong>Auto-save:</strong> Your work saves automatically every few seconds</li>
        <li><strong>Backup:</strong> Always download your transcript when finished</li>
      </ul>

      <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border); color: var(--text-muted); font-size: 13px;">
        <strong>Keyboard shortcuts:</strong> <span class="kbd">Space</span> Play/Pause • <span class="kbd">←</span><span class="kbd">→</span> Skip • <span class="kbd">Ctrl+S</span> Download
      </div>
    </section>

    <div class="footer">
      v1.3 • HEP Mobile Transcriber • Privacy-focused & offline-capable
    </div>
  </main>

  <!-- Mobile Dock -->
  <div class="mobile-dock">
    <div class="dock-controls">
      <button id="dockBack">⏪ Back</button>
      <button id="dockPlay" class="primary">▶️ Play</button>
      <button id="dockFwd">⏩ Forward</button>
    </div>
  </div>

  <script>
    // All the existing JavaScript functionality from the previous version
    const player = document.getElementById('player');
    const audioFile = document.getElementById('audioFile');
    const fileName = document.getElementById('fileName');
    const backBtn = document.getElementById('backBtn');
    const playBtn = document.getElementById('playBtn');
    const fwdBtn = document.getElementById('fwdBtn');
    const skipSeconds = document.getElementById('skipSeconds');
    const speedSel = document.getElementById('speed');
    const timeReadout = document.getElementById('timeReadout');

    const setLoopIn = document.getElementById('setLoopIn');
    const setLoopOut = document.getElementById('setLoopOut');
    const toggleLoop = document.getElementById('toggleLoop');
    const loopIn = document.getElementById('loopIn');
    const loopOut = document.getElementById('loopOut');

    // Progress bar elements
    const progressBar = document.getElementById('progressBar');
    const progressFill = document.getElementById('progressFill');
    const progressSlider = document.getElementById('progressSlider');

    const editor = document.getElementById('editor');
    const insertTs = document.getElementById('insertTs');
    const speakerPreset = document.getElementById('speakerPreset');
    const copyBtn = document.getElementById('copyBtn');
    const clearBtn = document.getElementById('clearBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const emailBtn = document.getElementById('emailBtn');
    const markBtn = document.getElementById('markBtn');
    const manualSave = document.getElementById('manualSave');
    const recoverBtn = document.getElementById('recoverBtn');
    
    const dockBack = document.getElementById('dockBack');
    const dockPlay = document.getElementById('dockPlay');
    const dockFwd = document.getElementById('dockFwd');

    const countInfo = document.getElementById('countInfo');
    const autosaveBadge = document.getElementById('autosaveBadge');
    const lastSaved = document.getElementById('lastSaved');
    const saveWarning = document.getElementById('saveWarning');

    let loopStart = null;
    let loopEnd = null;
    let doLoop = false;
    let currentFileKey = 'transcriber-default';
    let saveTimeout = null;
    let hasUnsavedChanges = false;

    // Enhanced save system (same as previous version)
    const saveSystem = {
      isAvailable: false,
      quotaExceeded: false,
      
      init() {
        try {
          const testKey = 'test-storage';
          localStorage.setItem(testKey, 'test');
          localStorage.removeItem(testKey);
          this.isAvailable = true;
          autosaveBadge.textContent = 'ON';
          autosaveBadge.className = 'badge success';
        } catch (e) {
          this.isAvailable = false;
          autosaveBadge.textContent = 'UNAVAILABLE';
          autosaveBadge.className = 'badge warning';
          console.warn('localStorage not available:', e);
        }
      },

      save(key, data) {
        if (!this.isAvailable) return false;
        
        try {
          const saveData = {
            content: data,
            timestamp: Date.now(),
            version: '1.3'
          };
          localStorage.setItem(key, JSON.stringify(saveData));
          
          const backupKey = key + '-backup-' + new Date().toISOString().slice(0,16);
          localStorage.setItem(backupKey, JSON.stringify(saveData));
          
          this.cleanOldBackups(key);
          
          this.quotaExceeded = false;
          autosaveBadge.textContent = 'ON';
          autosaveBadge.className = 'badge success';
          lastSaved.textContent = 'Saved ' + new Date().toLocaleTimeString();
          saveWarning.style.display = 'none';
          hasUnsavedChanges = false;
          return true;
        } catch (e) {
          if (e.name === 'QuotaExceededError') {
            this.quotaExceeded = true;
            autosaveBadge.textContent = 'QUOTA FULL';
            autosaveBadge.className = 'badge danger';
            saveWarning.style.display = 'block';
            this.cleanup();
          } else {
            autosaveBadge.textContent = 'FAILED';
            autosaveBadge.className = 'badge danger';
            saveWarning.style.display = 'block';
          }
          console.error('Save failed:', e);
          return false;
        }
      },

      load(key) {
        if (!this.isAvailable) return null;
        
        try {
          const stored = localStorage.getItem(key);
          if (!stored) return null;
          
          const data = JSON.parse(stored);
          return data.content || stored;
        } catch (e) {
          console.error('Load failed:', e);
          return null;
        }
      },

      cleanOldBackups(key) {
        try {
          const backupKeys = [];
          for (let i = 0; i < localStorage.length; i++) {
            const k = localStorage.key(i);
            if (k && k.startsWith(key + '-backup-')) {
              backupKeys.push(k);
            }
          }
          
          backupKeys.sort().reverse();
          for (let i = 3; i < backupKeys.length; i++) {
            localStorage.removeItem(backupKeys[i]);
          }
        } catch (e) {
          console.warn('Backup cleanup failed:', e);
        }
      },

      cleanup() {
        try {
          const keysToRemove = [];
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.includes('-backup-')) {
              keysToRemove.push(key);
            }
          }
          keysToRemove.forEach(key => localStorage.removeItem(key));
        } catch (e) {
          console.warn('Cleanup failed:', e);
        }
      },

      getBackups(key) {
        const backups = [];
        try {
          for (let i = 0; i < localStorage.length; i++) {
            const k = localStorage.key(i);
            if (k && k.startsWith(key + '-backup-')) {
              const data = JSON.parse(localStorage.getItem(k));
              backups.push({
                key: k,
                timestamp: data.timestamp,
                content: data.content
              });
            }
          }
          return backups.sort((a, b) => b.timestamp - a.timestamp);
        } catch (e) {
          return [];
        }
      }
    };

    function fmtTime(t) {
      if (!isFinite(t)) return '00:00';
      const h = Math.floor(t / 3600);
      const m = Math.floor((t % 3600) / 60);
      const s = Math.floor(t % 60);
      const hh = h > 0 ? String(h).padStart(2, '0') + ':' : '';
      return hh + String(m).padStart(2, '0') + ':' + String(s).padStart(2, '0');
    }

    function updateTimeReadout() {
      timeReadout.textContent = `${fmtTime(player.currentTime)} / ${fmtTime(player.duration)}`;
      updateProgressBar();
    }

    function updateProgressBar() {
      if (player.duration) {
        const progress = (player.currentTime / player.duration) * 100;
        progressFill.style.width = progress + '%';
        progressSlider.style.left = progress + '%';
      }
    }

    function updateCounts() {
      const text = editor.value;
      const chars = text.length;
      const words = (text.trim().match(/\S+/g) || []).length;
      countInfo.textContent = `${chars.toLocaleString()} chars • ${words.toLocaleString()} words`;
    }

    function saveLocal() {
      if (saveTimeout) clearTimeout(saveTimeout);
      
      saveTimeout = setTimeout(() => {
        const success = saveSystem.save(currentFileKey, editor.value);
        if (!success) {
          hasUnsavedChanges = true;
        }
      }, 2000);
    }

    function saveImmediately() {
      if (saveTimeout) clearTimeout(saveTimeout);
      return saveSystem.save(currentFileKey, editor.value);
    }

    function loadLocal() {
      const content = saveSystem.load(currentFileKey);
      if (content) {
        editor.value = content;
        updateCounts();
        lastSaved.textContent = 'Loaded previous work';
      }
      
      const backups = saveSystem.getBackups(currentFileKey);
      if (backups.length > 0) {
        recoverBtn.style.display = 'inline-block';
        recoverBtn.onclick = () => showBackupRecovery(backups);
      }
    }

    function showBackupRecovery(backups) {
      const options = backups.map((backup, i) => 
        `${i + 1}. ${new Date(backup.timestamp).toLocaleString()} (${backup.content.length} chars)`
      ).join('\n');
      
      const choice = prompt('Choose backup to recover:\n\n' + options + '\n\nEnter number (1-' + backups.length + ') or cancel:');
      const index = parseInt(choice) - 1;
      
      if (index >= 0 && index < backups.length) {
        if (confirm('This will replace your current text. Continue?')) {
          editor.value = backups[index].content;
          updateCounts();
          saveImmediately();
        }
      }
    }

    // Audio file loading
    audioFile.addEventListener('change', () => {
      const f = audioFile.files && audioFile.files[0];
      if (!f) {
        alert('No file selected. If the picker didn\'t appear, open this page in Chrome (not an in‑app browser) and make sure the audio is stored locally (e.g., Downloads). If it\'s in Google Drive, mark it Available offline first.');
        return;
      }
      const url = URL.createObjectURL(f);
      player.src = url;
      player.playbackRate = Number(speedSel.value || 1);
      fileName.textContent = f.name;
      
      const safeFileName = f.name.replace(/[^a-zA-Z0-9.-]/g, '_');
      currentFileKey = `transcriber-${safeFileName}-${f.size}`;
      
      loadLocal();
      loopStart = null; loopEnd = null; doLoop = false;
      loopIn.textContent = '–'; loopOut.textContent = '–'; toggleLoop.textContent = 'Loop: Off';
    });

    // Controls
    backBtn.addEventListener('click', () => {
      const s = Math.max(1, Number(skipSeconds.value) || 5);
      player.currentTime = Math.max(0, player.currentTime - s);
      updateTimeReadout();
    });

    fwdBtn.addEventListener('click', () => {
      const s = Math.max(1, Number(skipSeconds.value) || 5);
      player.currentTime = Math.min(player.duration || player.currentTime + s, player.currentTime + s);
      updateTimeReadout();
    });

    playBtn.addEventListener('click', () => {
      if (player.paused) {
        player.play().catch(()=>{});
        playBtn.textContent = '⏸️ Pause';
      } else {
        player.pause();
        playBtn.textContent = '▶️ Play';
      }
    });

    speedSel.addEventListener('change', () => {
      player.playbackRate = Number(speedSel.value || 1);
    });

    player.addEventListener('timeupdate', () => {
      updateTimeReadout();
      if (doLoop && loopStart !== null && loopEnd !== null) {
        if (player.currentTime >= loopEnd) {
          player.currentTime = loopStart;
          player.play().catch(()=>{});
        }
      }
    });

    player.addEventListener('loadedmetadata', () => {
      updateTimeReadout();
      updateProgressBar();
    });
    
    player.addEventListener('play', () => { 
      playBtn.textContent = '⏸️ Pause';
      if (dockPlay) dockPlay.textContent = '⏸️ Pause'; 
    });
    player.addEventListener('pause', () => { 
      playBtn.textContent = '▶️ Play';
      if (dockPlay) dockPlay.textContent = '▶️ Play'; 
    });

    if (dockBack) dockBack.addEventListener('click', () => backBtn.click());
    if (dockFwd) dockFwd.addEventListener('click', () => fwdBtn.click());
    if (dockPlay) dockPlay.addEventListener('click', () => playBtn.click());

    // Progress bar interaction
    let isDragging = false;

    progressBar.addEventListener('click', (e) => {
      if (!player.duration) return;
      const rect = progressBar.getBoundingClientRect();
      const percent = (e.clientX - rect.left) / rect.width;
      player.currentTime = percent * player.duration;
      updateTimeReadout();
    });

    progressSlider.addEventListener('mousedown', () => {
      isDragging = true;
      document.addEventListener('mousemove', handleDrag);
      document.addEventListener('mouseup', stopDrag);
    });

    progressSlider.addEventListener('touchstart', (e) => {
      isDragging = true;
      e.preventDefault();
      document.addEventListener('touchmove', handleTouchDrag, { passive: false });
      document.addEventListener('touchend', stopDrag);
    });

    function handleDrag(e) {
      if (!isDragging || !player.duration) return;
      const rect = progressBar.getBoundingClientRect();
      const percent = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
      player.currentTime = percent * player.duration;
      updateTimeReadout();
    }

    function handleTouchDrag(e) {
      if (!isDragging || !player.duration) return;
      e.preventDefault();
      const rect = progressBar.getBoundingClientRect();
      const touch = e.touches[0];
      const percent = Math.max(0, Math.min(1, (touch.clientX - rect.left) / rect.width));
      player.currentTime = percent * player.duration;
      updateTimeReadout();
    }

    function stopDrag() {
      isDragging = false;
      document.removeEventListener('mousemove', handleDrag);
      document.removeEventListener('mouseup', stopDrag);
      document.removeEventListener('touchmove', handleTouchDrag);
      document.removeEventListener('touchend', stopDrag);
    }

    // Loop controls with better functionality
    setLoopIn.addEventListener('click', () => {
      loopStart = player.currentTime;
      loopIn.textContent = fmtTime(loopStart);
      setLoopIn.style.background = 'var(--accent)';
      setLoopIn.style.color = 'white';
    });

    setLoopOut.addEventListener('click', () => {
      loopEnd = player.currentTime;
      loopOut.textContent = fmtTime(loopEnd);
      setLoopOut.style.background = 'var(--danger)';
      setLoopOut.style.color = 'white';
    });
    toggleLoop.addEventListener('click', () => {
      doLoop = !doLoop;
      toggleLoop.textContent = 'Loop: ' + (doLoop ? 'On' : 'Off');
      toggleLoop.style.background = doLoop ? 'var(--accent)' : 'transparent';
      toggleLoop.style.color = doLoop ? 'white' : 'var(--text)';
      
      if (doLoop && loopStart !== null && loopEnd !== null) {
        // Jump to loop start when enabling loop
        player.currentTime = loopStart;
        player.play().catch(()=>{});
      } else if (doLoop && (loopStart === null || loopEnd === null)) {
        alert('Please set both Loop In and Loop Out points first.');
        doLoop = false;
        toggleLoop.textContent = 'Loop: Off';
        toggleLoop.style.background = 'transparent';
        toggleLoop.style.color = 'var(--text)';
      }
    });

    // Editor features
    insertTs.addEventListener('click', () => {
      const ts = '[' + fmtTime(player.currentTime) + '] ';
      const start = editor.selectionStart;
      const end = editor.selectionEnd;
      editor.setRangeText(ts, start, end, 'end');
      updateCounts();
      saveLocal();
    });

    speakerPreset.addEventListener('change', () => {
      const val = speakerPreset.value;
      if (!val) return;
      const start = editor.selectionStart;
      const end = editor.selectionEnd;
      editor.setRangeText((start>0?'\n':'') + val + ' ', start, end, 'end');
      speakerPreset.selectedIndex = 0;
      updateCounts();
      saveLocal();
    });

    markBtn.addEventListener('click', () => {
      const tag = ' [UNCLEAR] ';
      const start = editor.selectionStart;
      const end = editor.selectionEnd;
      editor.setRangeText(tag, start, end, 'end');
      updateCounts();
      saveLocal();
    });

    editor.addEventListener('input', () => { 
      updateCounts(); 
      hasUnsavedChanges = true;
      saveLocal(); 
    });

    manualSave.addEventListener('click', () => {
      const success = saveImmediately();
      if (success) {
        manualSave.textContent = '✅ Saved';
        setTimeout(() => manualSave.textContent = '💾 Save Now', 2000);
      } else {
        manualSave.textContent = '❌ Failed';
        setTimeout(() => manualSave.textContent = '💾 Save Now', 2000);
      }
    });

    copyBtn.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(editor.value);
        copyBtn.textContent = '✅ Copied';
      } catch (e) {
        editor.select();
        document.execCommand('copy');
        copyBtn.textContent = '✅ Copied';
      } finally {
        setTimeout(() => copyBtn.textContent = '📋 Copy', 1000);
      }
    });

    clearBtn.addEventListener('click', () => {
      if (!confirm('Clear all text?')) return;
      editor.value = '';
      updateCounts();
      saveImmediately();
    });

    function download(filename, text) {
      const blob = new Blob([text], {type: 'text/plain'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    downloadBtn.addEventListener('click', () => {
      const base = (fileName.textContent || 'audio').replace(/\.[^/.]+$/, '');
      const timestamp = new Date().toISOString().slice(0,16).replace(/[T:]/g, '-');
      download(`${base}-transcript-${timestamp}.txt`, editor.value);
      saveImmediately();
    });

    // Email functionality with fallback
    emailBtn.addEventListener('click', () => {
      const base = (fileName.textContent || 'audio').replace(/\.[^/.]+$/, '');
      const timestamp = new Date().toISOString().slice(0,16).replace(/[T:]/g, '-');
      const filename = `${base}-transcript-${timestamp}.txt`;
      const transcriptText = editor.value;
      
      // Check if transcript is empty
      if (!transcriptText.trim()) {
        alert('Please add some transcript text before emailing.');
        return;
      }

      // For mobile devices, try the Web Share API first (if available)
      if (navigator.share && /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
        // Create a blob and try to share it
        const blob = new Blob([transcriptText], { type: 'text/plain' });
        const file = new File([blob], filename, { type: 'text/plain' });
        
        if (navigator.canShare && navigator.canShare({ files: [file] })) {
          navigator.share({
            title: 'Transcript',
            text: 'Please find the attached transcript.',
            files: [file]
          }).catch((error) => {
            console.log('Share failed:', error);
            fallbackEmail();
          });
          return;
        }
      }
      
      // Fallback: mailto with text in body
      function fallbackEmail() {
        const subject = encodeURIComponent(`Transcript: ${base}`);
        const bodyText = `Please find the transcript below:\n\n--- TRANSCRIPT START ---\n\n${transcriptText}\n\n--- TRANSCRIPT END ---\n\nGenerated on: ${new Date().toLocaleString()}\nFile: ${filename}`;
        const body = encodeURIComponent(bodyText);
        
        // Construct mailto URL
        const mailtoUrl = `mailto:?subject=${subject}&body=${body}`;
        
        // Check if the mailto URL is too long (some email clients have limits)
        if (mailtoUrl.length > 2000) {
          // If too long, provide alternative options
          if (confirm('The transcript is too long for email. Would you like to:\n\n1. Click OK to download the file and attach it manually\n2. Click Cancel to copy the text to clipboard instead')) {
            // Download the file
            download(filename, transcriptText);
            alert('File downloaded! You can now attach it to your email manually.');
          } else {
            // Copy to clipboard
            copyToClipboard(transcriptText);
          }
        } else {
          // Open mailto link
          try {
            window.location.href = mailtoUrl;
            
            // Show helpful message
            setTimeout(() => {
              alert('If your email client didn\'t open:\n\n1. Copy the text using the "Copy" button\n2. Or download the file and attach it manually\n3. Make sure you have a default email app set up');
            }, 1000);
          } catch (error) {
            console.error('mailto failed:', error);
            if (confirm('Could not open email client. Would you like to download the file instead?')) {
              download(filename, transcriptText);
            }
          }
        }
      }
      
      // Call fallback directly for desktop or if Web Share API not available
      fallbackEmail();
    });

    // Helper function for copying to clipboard
    async function copyToClipboard(text) {
      try {
        await navigator.clipboard.writeText(text);
        alert('Transcript copied to clipboard! You can now paste it into your email.');
      } catch (e) {
        // Fallback for older browsers
        const textarea = document.createElement('textarea');
        textarea.value = text;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand('copy');
        document.body.removeChild(textarea);
        alert('Transcript copied to clipboard! You can now paste it into your email.');
      }
    }

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space' && e.target !== editor) {
        e.preventDefault();
        playBtn.click();
      }
      
      if (e.target !== editor) {
        if (e.code === 'ArrowLeft') {
          e.preventDefault();
          backBtn.click();
        } else if (e.code === 'ArrowRight') {
          e.preventDefault();
          fwdBtn.click();
        }
      }
      
      if ((e.ctrlKey || e.metaKey) && e.code === 'KeyS') {
        e.preventDefault();
        downloadBtn.click();
      }
      
      if ((e.ctrlKey || e.metaKey) && e.code === 'KeyD') {
        e.preventDefault();
        manualSave.click();
      }
    });

    window.addEventListener('beforeunload', (e) => {
      if (hasUnsavedChanges) {
        e.preventDefault();
        e.returnValue = 'You have unsaved changes. Download your transcript or copy the text before leaving.';
        return e.returnValue;
      }
    });

    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden' && hasUnsavedChanges) {
        saveImmediately();
      }
    });

    // Initialize
    saveSystem.init();
    updateCounts();

    try {
      const ua = navigator.userAgent || '';
      const host = location.hostname || '';
      const inApp = /FBAN|FBAV|Instagram|Line\//i.test(ua);
      const onGitHubCodeViewer = /github\.com$/i.test(host);
      if (inApp || onGitHubCodeViewer) {
        document.getElementById('envWarning').style.display = 'block';
      }
    } catch (_) {}

    if (!saveSystem.load('transcriber-hasVisited')) {
      setTimeout(() => {
        alert('Welcome! This transcriber saves your work automatically. If auto-save fails, use "Download" to backup your transcript. Everything stays on your device - no uploads.');
        saveSystem.save('transcriber-hasVisited', 'true');
      }, 1000);
    }
  </script>
</body>
</html>
